#include "mini_db.hpp"
#include <iostream>
#include <map>
#include <fstream>
#include <signal.h>
#include <cstdlib> // ADDED: per atoi()


std::string path;
std::map<std::string, std::string> db;


void handler(int signalNum){
	std::ofstream file(path);
	if(!file.is_open())
	{
		std::cout << "Invalid file path" << std::endl;
		exit(signalNum); 
	}
	for (auto const&[key, value] : db){
		file << key << " " << value << std::endl;
	}
	file.close();
	exit(signalNum);
}

void readDb(){
	std::ifstream file(path);
	if(!file.is_open())
		return;
	std::string key, value;
	while(file >> key >> value){
		db[key] = value;
	}
}

int main(int ac, char **av)
{
	if(ac != 3)
	{
		std::cout << "Wrong number of argument" << std::endl;
		return (1); 
	}
	signal(SIGINT, handler);
	path = av[2];
	readDb();
	Server server(atoi(av[1]), db);
	server.run();
	return 0;
}

#include <iostream>
#include <stdexcept>
#include <cstring>
#include <netinet/in.h>
#include <sys/socket.h>
#include <unistd.h>
#include <map>
#include <sstream>
#include <sys/select.h>  // ADDED: per select() non-blocking
#include <fcntl.h>       // ADDED: per fcntl() O_NONBLOCK


//copy all the main.c in the subject
class Socket
{
private:
	int _sockfd;
	struct sockaddr_in _servaddr;

public:
	Socket(int port) :
			_sockfd(socket(AF_INET, SOCK_STREAM, 0))
		{
			if(_sockfd == -1){
				throw std::runtime_error("Socket creation failed");
			}

			// ADDED: Imposta socket come non-blocking
			if (fcntl(_sockfd, F_SETFL, O_NONBLOCK) < 0) {
				throw std::runtime_error("Failed to set socket non-blocking");
			}

			memset(&_servaddr, 0, sizeof(_servaddr));
			_servaddr.sin_family = AF_INET;
			_servaddr.sin_addr.s_addr = htonl(INADDR_LOOPBACK); // FIXED: 127.0.0.1 specifico
			_servaddr.sin_port = htons(port);
		}
//
	~Socket()
		{
			if (_sockfd != -1)
			{
				close(_sockfd);
			}
		}
	void bindAndListen()
		{
			if(bind(_sockfd, (struct sockaddr *)&_servaddr, sizeof(_servaddr)) < 0)
			{
				throw std::runtime_error("Socket bind failed");
			}

			if (listen(_sockfd, 10) < 0)
			{
				throw std::runtime_error("Socket listen failed");
			}
		}
	int accept(struct sockaddr_in& clientAddr)
		{
			socklen_t clientLen = sizeof(clientAddr);
			int clientSocketFd = ::accept(_sockfd, (struct sockaddr*)&clientAddr, &clientLen);
			if(clientSocketFd < 0)
			{
				return -1; // FIXED: Non-blocking - ritorna -1 invece di eccezione
			}

			// ADDED: Imposta anche client socket come non-blocking
			if (fcntl(clientSocketFd, F_SETFL, O_NONBLOCK) < 0) {
				close(clientSocketFd);
				return -1;
			}

			return clientSocketFd;
		}

	// ADDED: Getter per ottenere socket fd per select()
	int getSocketFd() const { return _sockfd; }
};

class Server
{
private: 
	Socket _listeningSocket;
	std::map<std::string, std::string> &db;
	std::map<int, std::string> clientBuffers; // ADDED: Buffer per messaggi parziali
	fd_set readfds, activefds; // ADDED: Set per select()
	int maxfd; // ADDED: Massimo FD per select()
//
public:
	Server(int port, std::map<std::string, std::string>&database) :
		_listeningSocket(port), db(database), maxfd(0)
		{
			FD_ZERO(&activefds); // ADDED: Inizializza set FD
		}
	//add handler function
	void handlemessage(int clientFd, const std::string& message){
		std::istringstream msg(message);
		std::string command, key, value;
		msg >> command >> key >> value;
		if(command == "POST" && !key.empty() && !value.empty()){ // FIXED: Added !key.empty() check
			db[key] = value;
			send(clientFd, "0\n", 2, 0);
		}
		else if(command == "GET" && !key.empty() && value.empty()){ // FIXED: Added !key.empty() check
			auto it = db.find(key);
			if(it != db.end()){
				std::string ret = "0 " + it->second + '\n';
				send(clientFd, ret.c_str(), ret.size(), 0);
			}
			else
				send(clientFd, "1\n", 2 ,0);

		}else if(command == "DELETE" && !key.empty() && value.empty()){ // FIXED: Added !key.empty() check
			auto it = db.find(key);
			if(it != db.end()){
				db.erase(it);
				send(clientFd, "0\n", 2, 0);
			}
			else
				send(clientFd, "1\n", 2 ,0);
		}else{
			send(clientFd, "2\n", 2, 0);
		}
	}

	// ADDED: Gestisce nuovo client
	void handleNewClient() {
		struct sockaddr_in clientAddr;
		int clientFd = _listeningSocket.accept(clientAddr);
		
		if (clientFd < 0) {
			return; // Non-blocking: nessun client in attesa
		}

		// Aggiungi al set attivo
		FD_SET(clientFd, &activefds);
		if (clientFd > maxfd) maxfd = clientFd;
		
		// Inizializza buffer per questo client
		clientBuffers[clientFd] = "";
	}

	// ADDED: Gestisce messaggio da client
	void handleClientMessage(int clientFd) {
		char buf[1024];
		int bytes_read = recv(clientFd, buf, 1000, 0);
		
		if (bytes_read <= 0) {
			// Client disconnesso
			FD_CLR(clientFd, &activefds);
			close(clientFd);
			clientBuffers.erase(clientFd);
			return;
		}
		
		buf[bytes_read] = '\0';
		clientBuffers[clientFd] += std::string(buf);
		
		// Processa messaggi completi (terminati da \n)
		processCompleteMessages(clientFd);
	}

	// ADDED: Processa messaggi completi
	void processCompleteMessages(int clientFd) {
		std::string& buffer = clientBuffers[clientFd];
		size_t pos = 0;
		
		while((pos = buffer.find('\n')) != std::string::npos) {
			std::string message = buffer.substr(0, pos);
			buffer.erase(0, pos + 1); // Rimuovi messaggio processato
			
			if(!message.empty()) {
				handlemessage(clientFd, message);
			}
		}
	}
	int run()
		{
			try
			{
				_listeningSocket.bindAndListen();
				std::cout << "ready" << std::endl;
				
				// ADDED: Setup select() - aggiungi server socket al set
				int serverfd = _listeningSocket.getSocketFd();
				FD_SET(serverfd, &activefds);
				maxfd = serverfd;
				
				while(true) {
					readfds = activefds; // Copia set attivo
					
					// ADDED: SELECT NON-BLOCKING - aspetta attività su qualsiasi FD
					if(select(maxfd + 1, &readfds, NULL, NULL, NULL) < 0) {
						std::cerr << "Select error" << std::endl;
						continue;
					}
					
					// ADDED: Controlla tutti i file descriptor per attività
					for(int fd = 0; fd <= maxfd; fd++) {
						if(!FD_ISSET(fd, &readfds)) continue;
						
						if(fd == serverfd) {
							// ADDED: Nuovo client
							handleNewClient();
						} else {
							// ADDED: Messaggio da client esistente
							handleClientMessage(fd);
						}
					}
				}
				return 0; //Success
			}
			catch(const std::exception& e)
			{
				std::cerr << "Error during server run: " << e.what() << std::endl;
				return 1; // Return error code if server fails to start
			}
		}
};